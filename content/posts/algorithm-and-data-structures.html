---
title: アルゴリズムとデータ構造
linkTitle: <span lang=ja>アルゴリズムとデータ構造</span> <span lang=en>Algorithm and Data Structures</span>
date: 2021-10-09T19:37:26+09:00
draft: false
isCJKLanguage: true
mathJax: true
---

<article lang="ja">
  <h1 lang="ja">アルゴリズムとデータ構造</h1>
  <section>
    <h2>アルゴリズムの計算量</h2>
    <p>実行できる基本演算とそのコストを定めた計算機構を<dfn>計算モデル</dfn>という。</p>
    <p>ランダムアクセス機械（<abbr lang="en" title="random access machine">RAM</abbr>）</p>
    <ul>
      <li>プログラム：命令の列</li>
      <li>命令セット</li>
      <li>プログラムカウンタ（<abbr>PC</abbr>）</li>
      <li>レジスタ（メモリ単位）：一つの整数もしくは実数を格納</li>
    </ul>
    <p>アルゴリズムは計算モデル上で評価する。</p>
    <p>RAM を用いたアルゴリズムの評価：実行される命令数がアルゴリズムの計算時間，使用されるレジスタ数がアルゴリズムで使用される記憶領域。</p>
    <p>RAM における評価基準：</p>
    <ul>
      <li>一様コスト基準（<span lang="en">uniform cost criterion</span>）：どの命令も単位時間で実行できると仮定</li>
      <li>対数コスト基準（<span lang="en">logarithmic cost criterion</span>）：データを処理する命令では対象のデータの長さ（ビット数）に比例する時間がかかると仮定</li>
    </ul>
    <p>アルゴリズムを計算モデルで実行した場合の計算時間（実行した命令数）を<dfn>時間計算量</dfn>（<span lang="en">time complexity</span>），使用した記憶領域の最大量（使用した最大レジスタ数）を<dfn>領域計算量</dfn>（<span lang="en">space complexity</span>）と呼ぶ。</p>
    <p>入力サイズ（<span lang="en">input size</span>） n を変数として計算時間（メモリ量）を表す関数 f(n) を計算量と呼ぶ。</p>
    <p>入力サイズ n を大きくしていった時の計算量 f(n) のふるまいを<dfn>漸進的計算量</dfn>（<span lang="en">asymptotic complexity</span>）という。</p>
    <p>十分大きな n に対して f(n) が g(n) の定数倍で上から抑えられるとき，計算量は<dfn>オーダ</dfn>（order） g(n) であるといい，O(g(n)) と表記する。</p>
    <p>平均計算量（<span lang="en">average-case complexity</span>），最悪計算量（<span lang="en">worst-case complexity</span>），最良計算量（<span lang="en">best-case complexity</span>）</p>
    <p>O(n<sup>k</sup>) は<dfn>多項式計算量</dfn>（<span lang="en">polynomial complexity</span>）という。多項式時間計算量を持つアルゴリズムは<dfn>多項式時間アルゴリズム</dfn>（<span lang="en">polynomial-time algorithm</span>）と呼ばれる。</p>
    <p><dfn>&Omega;表記</dfn> f(n)=&Omega;(g(n)) 十分大きな n に対して f(n) が g(n) の定数倍で下から抑えられる</p>
    <p><dfn>&Theta;表記</dfn> f(n)=O(g(n)) かつ f(n)=&Omega;(g(n)) のとき，f(n)=&Theta;(g(n))</p>
  </section>
  <section>
    <h2>グラフ（<span lang="en">Graph</span>）</h2>
    <table>
      <caption>用語</caption>
      <thead>
        <tr><th>日本語</th><th>英語</th></tr>
      </thead>
      <tbody>
        <tr><td>頂点</td><td lang="en">vertex / vertices</td></tr>
        <tr><td>辺</td><td lang="en">edge</td></tr>
        <tr><td>多重辺</td><td lang="en">parallel edge</td></tr>
        <tr><td>有向グラフ</td><td lang="en">directed graph</td></tr>
        <tr><td>無向グラフ</td><td lang="en">undirected graph</td></tr>
        <tr><td>部分グラフ</td><td lang="en">subgraph</td></tr>
      </tbody>
    </table>
    <p>頂点 u と頂点 v を結ぶ辺は e=(u,v) 。u と v は辺 e の<dfn>端点</dfn>（<span lang=en>end vertex</span>）といい，e は u と v に<dfn>接続</dfn>（<span lang=en>incident</span>）しているという。u と v は<dfn>隣接</dfn>（<span lang="en">adjacent</span>）しているという。頂点 u に接続している辺の本数は u の<dfn>次数</dfn>（<span lang="en">degree</span>）という。e が有向グラフの辺のとき，u は辺 e の<dfn>始点</dfn>（<span lang=en>initial vertex</span>），v は辺 e の<dfn>終点</dfn>（<span lang="en">terminal vertex</span>）という。頂点 u を始点とする辺の本数を u の<dfn>出次数</dfn>（<span lang="en">outdegree</span>）といい，頂点 u を終点とする辺の本数を u の<dfn>入次数</dfn>（<span lang="en">indegree</span>）という。</p>
    <p><dfn><abbr title="directed acyclic graph">DAG</abbr></dfn>：有向閉路を含まない有向グラフ。</p>
    <p>連結な無向グラフ G の全ての頂点を含む部分グラフで，木であるものを G の<dfn>スパニング木</dfn>（<span lang="en">spanning tree</span>）または<dfn>全域木</dfn>という。</p>
    <p><dfn>行列木定理</dfn>：G のスパニング木の個数は G のラプラシアン L(G) の任意の対角要素に関する<a href="https://ja.wikipedia.org/wiki/%E5%B0%8F%E8%A1%8C%E5%88%97%E5%BC%8F" target="_blank" title="余因子">余因子</a>の値に等しい。</p>
    <p><dfn>ラプラシアン</dfn> L(G) = D &minus; A<br>D は各頂点の次数からなる対角行列，A は G の隣接行列。</p>
  </section>
  <section>
    <h2>木（<span lang="en">Tree</span>）</h2>
    <table>
      <caption>用語</caption>
      <thead>
        <tr>
          <th>日本語</th>
          <th>英語</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>頂点</td>
          <td>vertex / vertices</td>
        </tr>
        <tr>
          <td>根</td>
          <td lang="en">root</td>
        </tr>
        <tr>
          <td>親</td>
          <td lang="en">parent</td>
        </tr>
        <tr>
          <td>子</td>
          <td lang="en">child / children</td>
        </tr>
        <tr>
          <td>兄弟</td>
          <td lang="en">sibling</td>
        </tr>
        <tr>
          <td>先祖</td>
          <td lang="en">ancestor</td>
        </tr>
        <tr>
          <td>子孫</td>
          <td lang="en">descendent</td>
        </tr>
        <tr>
          <td>葉</td>
          <td>leaf</td>
        </tr>
        <tr>
          <td>部分木</td>
          <td>subtree</td>
        </tr>
      </tbody>
    </table>
    <p>根から頂点 v への単純路の長さを v の<dfn>深さ</dfn>（<span lang="en">depth</span>）といい，v から v の子孫への最長の単純路の長さを v の<dfn>高さ</dfn>（<span lang="en">height</span>）という。</p>
    <p>閉路のない無向グラフを<dfn>森</dfn>（<span lang="en">forest</span>）と呼び，連結な森を<dfn>木</dfn>（<span lang="en">tree</span>）と呼ぶ。</p>
    <p>根を持つ木を<dfn>根付き木</dfn>（<span lang="en">rooted tree</span>）といい，子の間に順番を考える場合は<dfn>順序木</dfn>（<span lang="en">ordered tree</span>）と呼ぶ。</p>
    <p>各頂点が高々2個の子しか持たない根付き木を <dfn>2 分木</dfn>（binary tree）という。</p>
    <p>上から順に頂点が詰まっていて，最下段の頂点は左詰めになっている2 分木を<dfn>完全 2 分木</dfn>と呼ぶ。</p>
    <p>完全 2 分木は配列で表現可能。i の親は &lfloor;(i&minus;1)/2&rfloor; ，左の子は 2i+1 。</p>
    <p>頂点を 1 度ずつ訪れることを<dfn>走査</dfn>という。</p>
    <p>2 分木における頂点の走査：先行順（<span lang=en>preorder</span>）（根&rightarrow;左&rightarrow;右），中間順（<span lang=en>inorder</span>）（左&rightarrow;根&rightarrow;右），後行順（<span lang=en>postorder</span>）（左&rightarrow;右&rightarrow;根）。</p>
  </section>
  <section>
    <h2>リスト（<span lang="en">List, linked list</span>）</h2>
    <p>セル（<span lang=en>cell</span>）＝データ部＋ポインタ部</p>
    <p>リストの基本操作：データの挿入・削除・参照・存在判定</p>
    <p>リストの利点：挿入・削除が容易，保持できるデータの最大数が可変。</p>

    <p>先頭でのみ要素の挿入・削除・参照を行えるリストを<dfn>スタック</dfn>（<span lang=en>Stack</span>）という。</p>
    <p>スタックは<strong>後入れ先出し</strong>（<abbr lang="en" title="last-in first-out">LIFO</abbr>）方式のデータ構造。</p>
    <p>スタックの基本操作：（先頭に）要素を追加する操作はプッシュ（<span lang="en">push</span>），（先頭）要素を取り出す操作はポップ（<span lang=en>pop</span>）と呼ばれる。</p>
    <p>要素の挿入を一方の端で，削除を他方の端で行うリストを<dfn>キュー</dfn>（<span lang=en>queue</span>）という。</p>
    <p>キューは<strong>先入れ先出し</strong>（<abbr lang=en title="first-in first-out">FIFO</abbr>）方式のデータ構造。</p>
    <p>キューの基本操作は挿入・取り出し・参照・削除など。</p>
  </section>
  <section>
    <h2>ヒープ（<span lang="en">Heap</span>）</h2>
    <p>順序集合から最小の要素を繰り返して取り出すためのデータ構造は<dfn>ヒープ</dfn>（<span lang="en">heap</span>），または<dfn>優先順位付きキュー</dfn>と呼ばれる。</p>
    <p>各頂点に順序集合の要素を 1 対 1 に対応させた 2 分木で，親子関係にある頂点間で以下の条件（<strong>ヒープ条件</strong>）が成立：①親の要素は子の要素より小さい。②根に対応する要素が最小。</p>
    <p>ヒープの基本操作：要素の挿入，最小要素（根の要素）の削除，最小要素の参照。</p>
    <p>ヒープを常に完全 2 分木とすることで挿入・最小値削除を \(O(\log n)\) で実現可能（頂点数 n の完全 2 分木の高さは \(\lfloor\log n\rfloor\) ）。</p>
    <p>完全 2 分木ヒープへの要素の挿入：</p>
    <ol>
      <li>完全 2 分木であることを保つ位置に追加したい要素を追加 O(log n)</li>
      <li>追加した頂点を注目する頂点に設定</li>
      <li>注目している頂点とその親がヒープ条件を満たさなければ，それらの要素を入れ替えて，注目頂点を親に設定し繰り返す</li>
      <li>ヒープ条件を満たしていれば終了</li>
    </ol>
    <p>完全 2 分木ヒープの最小要素の削除：</p>
    <ol>
      <li>最も深く最も右にある葉を削除し，その要素を根の要素に書き換える O(log n)</li>
      <li>根を注目する頂点に設定</li>
      <li>注目している頂点と左右の子がヒープ条件を満たさなければ，ヒープ条件を満たさない子のうちの<strong>小さい方</strong>と注目頂点の要素を入れ替えて，注目頂点を入れ替えた方の子に設定し繰り返す</li>
      <li>ヒープ条件を満たしていれば終了</li>
    </ol>
  </section>
  <section>
    <h2>整列 / ソーティング（<span lang=en>Sorting</span>）</h2>
    <p>バブルソート（<span lang=en>bubble sort</span>）</p>
{{< highlight cpp >}}
void bubblesort(int data[], int n)
{
  int i, j, t, sw = 1;
  for (i = 1; sw && i < n; i++)
  {
    sw = 0;
    for (j = n - 1; j >= i; j--)
    {
      if (data[j - 1] > data[j])
      {
        t = data[j - 1];
        data[j - 1] = data[j];
        data[j] = t;
        sw = 1;
      }
    }
  }
  return;
}
{{< /highlight >}}
<p>挿入ソート（<span lang=en>insert sort</span>）</p>
{{< highlight cpp >}}
void insertsort(int data[], int n)
{
  int i, j, k, t;
  for (i = 1; i < n; i++)
  {
    for (j = i - 1; j >= 0; j--)
    {
      if (data[j + 1] < data[j])
      {
        t = data[j + 1];
        data[j + 1] = data[j];
        data[j] = t;
      }
      else
      {
        break;
      }
    }
  }
  return;
}
{{< /highlight >}}
<p>クイックソート（<span lang=en>quick sort</span>）</p>
{{< highlight cpp >}}
void quicksort(int data[], int first, int last) {
  int i, j, x, t;
  x = data[(first + last) / 2];
  for (i = first, j = last; 1; i++, j--) {
    while (data[i] < x) i++;
    while (x < data[j]) j--;
    if (i >= j) break;
    t = data[i];
    data[i] = data[j];
    data[j] = t;
  }
  if (first < i - 1)
    quicksort(data, first, i - 1);
  if (j + 1 < last)
    quicksort(data, j + 1, last);
}
{{< /highlight >}}

  </section>
</article>